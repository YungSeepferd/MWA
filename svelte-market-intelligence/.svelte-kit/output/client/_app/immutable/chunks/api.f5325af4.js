var d=Object.defineProperty;var l=(c,e,t)=>e in c?d(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var o=(c,e,t)=>(l(c,typeof e!="symbol"?e+"":e,t),t);import{e as h,E as u,a as p}from"./errorHandler.253b2d9d.js";class g{constructor(e="/api"){o(this,"baseURL");o(this,"defaultHeaders");this.baseURL=e,this.defaultHeaders={"Content-Type":"application/json",Accept:"application/json"}}async request(e,t={},s=1){const a=`${this.baseURL}${e}`,n={...t,headers:{...this.defaultHeaders,...t.headers}};try{const r=await fetch(a,n);if(!r.ok){const i=await r.json().catch(()=>({code:"NETWORK_ERROR",message:"Failed to parse error response",timestamp:new Date().toISOString()}));if(r.status>=500&&s<3)return await this.delay(1e3*s),this.request(e,t,s+1);throw new Error(`API Error: ${i.message} (${i.code})`)}return await r.json()}catch(r){const i=h.handleError(r,`API:${e}`);throw r instanceof TypeError&&r.message.includes("Failed to fetch")?h.handleError({code:u.NETWORK_ERROR,message:p.NETWORK_OFFLINE},`API:${e}`):i}}delay(e){return new Promise(t=>setTimeout(t,e))}async getContacts(e){const t=new URLSearchParams;e?.page&&t.append("page",e.page.toString()),e?.pageSize&&t.append("page_size",e.pageSize.toString()),e?.search&&t.append("search",e.search);const s=`/contacts${t.toString()?`?${t}`:""}`;return this.request(s)}async searchContacts(e){return this.request("/contacts/search",{method:"POST",body:JSON.stringify(e)})}async getContact(e){return this.request(`/contacts/${e}`)}async createContact(e){return this.request("/contacts",{method:"POST",body:JSON.stringify(e)})}async updateContact(e,t){return this.request(`/contacts/${e}`,{method:"PUT",body:JSON.stringify(t)})}async deleteContact(e){return this.request(`/contacts/${e}`,{method:"DELETE"})}async approveContact(e){return this.request(`/contacts/${e}/approve`,{method:"POST"})}async rejectContact(e,t){return this.request(`/contacts/${e}/reject`,{method:"POST",body:t?JSON.stringify({rejection_reason:t}):void 0})}async getContactScoring(e){return this.request(`/contacts/${e}/scoring`)}async getAnalytics(){return this.request("/analytics")}async healthCheck(){try{return(await fetch(`${this.baseURL}/health`,{method:"GET",headers:this.defaultHeaders})).ok}catch{return!1}}async exportContacts(e){return this.request("/export",{method:"POST",body:JSON.stringify(e)})}async getExportStatus(e){return this.request(`/export/${e}`)}async bulkApproveContacts(e){return this.request("/contacts/bulk/approve",{method:"POST",body:JSON.stringify({contact_ids:e})})}async bulkRejectContacts(e,t){return this.request("/contacts/bulk/reject",{method:"POST",body:JSON.stringify({contact_ids:e,rejection_reason:t})})}}const m=new g;class y{constructor(e="/ws"){o(this,"ws",null);o(this,"reconnectAttempts",0);o(this,"maxReconnectAttempts",5);o(this,"reconnectDelay",1e3);o(this,"messageHandlers",new Map);this.baseURL=e}connect(){return new Promise((e,t)=>{try{const a=`${window.location.protocol==="https:"?"wss:":"ws:"}//${window.location.host}${this.baseURL}`;this.ws=new WebSocket(a),this.ws.onopen=()=>{console.log("WebSocket connected"),this.reconnectAttempts=0,e()},this.ws.onmessage=n=>{this.handleMessage(JSON.parse(n.data))},this.ws.onclose=n=>{console.log("WebSocket disconnected:",n.code,n.reason),this.handleReconnect()},this.ws.onerror=n=>{console.error("WebSocket error:",n),t(n)}}catch(s){t(s)}})}handleReconnect(){this.reconnectAttempts<this.maxReconnectAttempts?(this.reconnectAttempts++,console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`),setTimeout(()=>{this.connect().catch(()=>this.handleReconnect())},this.reconnectDelay*this.reconnectAttempts)):console.error("Max reconnection attempts reached")}handleMessage(e){(this.messageHandlers.get(e.type)||[]).forEach(s=>s(e.data))}on(e,t){this.messageHandlers.has(e)||this.messageHandlers.set(e,[]),this.messageHandlers.get(e).push(t)}off(e,t){const s=this.messageHandlers.get(e);if(s){const a=s.indexOf(t);a>-1&&s.splice(a,1)}}send(e){this.ws&&this.ws.readyState===WebSocket.OPEN&&this.ws.send(JSON.stringify(e))}disconnect(){this.ws&&(this.ws.close(),this.ws=null),this.messageHandlers.clear()}}const f=new y;export{m as a,f as w};
